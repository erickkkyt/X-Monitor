# Vercel 部署错误复盘

本文档记录了在将 X-Monitor 项目部署到 Vercel 过程中遇到的一系列构建错误及其解决方法。

## 1. ESLint: 未使用的变量/参数/导入 (`@typescript-eslint/no-unused-vars`)

*   **问题简述**: 在多个 `.ts` 和 `.tsx` 文件中，构建因存在未使用的变量、函数参数或导入而失败。
*   **产生原因**: 项目启用了严格的 ESLint 规则 (`@typescript-eslint/no-unused-vars`)，该规则不允许存在未使用的代码元素。在 Vercel 构建环境中，即使使用了常见的 `_` 前缀来标记故意未使用的参数（如 `_channel`），或者使用了 `eslint-disable-next-line` 注释，该规则有时仍然报错，表明构建环境的 ESLint 配置或解释可能比预期的更严格或存在差异。
*   **解决方法**: 
    1.  **移除**: 对于确实不再需要的变量或导入，直接从代码中删除。
    2.  **修改 ESLint 配置**: 对于需要保留但确实未使用的参数（如下划线开头的参数 `_channel`），最终通过修改根目录下的 `eslint.config.mjs` 文件解决。明确配置了 `@typescript-eslint/no-unused-vars` 规则，使用 `argsIgnorePattern: '^_'` 等选项来全局忽略以下划线开头的标识符。这需要安装 `typescript-eslint` 依赖。
    3.  **早期尝试 (部分有效/无效)**: 
        *   添加 `_` 前缀：对某些变量/参数有效，但对 `_channel` 无效。
        *   添加 `eslint-disable-next-line` 注释：在 Vercel 环境中似乎也未能完全解决问题。

## 2. TypeScript: `catch` 子句变量类型注解错误

*   **问题简述**: 在多个 `try...catch` 语句中，`catch (error: Error)` 的写法导致类型错误。
*   **产生原因**: TypeScript 的类型检查规则（尤其在 `strict` 模式下）要求 `catch` 子句捕获的变量类型必须是 `any` 或 `unknown`，因为 `throw` 语句可以抛出任何类型的值，不能保证捕获到的一定是 `Error` 类的实例。
*   **解决方法**: 将 `catch (error: Error)` 修改为 `catch (error: unknown)`，并在 `catch` 块内部需要访问 `error.message` 等 `Error` 特有属性之前，使用 `instanceof Error` 进行类型守卫，例如：`const message = error instanceof Error ? error.message : '默认错误信息';`。

## 3. TypeScript: 页面组件 `searchParams` 类型不匹配 (`Promise<any>` 问题)

*   **问题简述**: 在 `src/app/login/page.tsx` (以及最初的 `src/app/error-page/page.tsx`) 中，构建失败，提示组件属性类型不满足 `PageProps` 约束，且错误地将 `searchParams` 的预期类型显示为 `Promise<any>`。
*   **产生原因**: 根据用户提供的参考资料，这是 Next.js 15 中的一个行为变化（可能与生成的类型或内部实现有关），导致页面/布局组件的 `params` 和 `searchParams` 属性被视为 Promise。
*   **解决方法**: 
    1.  将受影响的页面组件声明为 `async function`。
    2.  修改组件属性类型定义，将 `searchParams` (或 `params`) 的类型注解为 `Promise<YourParamType>`。
    3.  在组件函数体内部，使用 `await` 来解析 `searchParams` (或 `params`) Promise，获取实际的参数对象后再使用。

## 4. TypeScript: 函数参数缺少类型注解 (`implicitly has an 'any' type`)

*   **问题简述**: 在 `src/app/dashboard/notifications/page.tsx` 中，`validatePhoneNumber` 等函数的参数没有明确的类型注解。
*   **产生原因**: 项目启用了 TypeScript 的 `noImplicitAny` 规则（通常是 `strict` 模式的一部分），不允许变量或参数隐式地拥有 `any` 类型。
*   **解决方法**: 为所有函数参数添加明确的类型注解，例如 `(number: string)`，`(e: React.ChangeEvent<HTMLInputElement>)` 等。

## 5. TypeScript: `useState` 类型推断错误

*   **问题简述**: 在 `src/app/pricing/page.tsx` 的 `PricingHeader` 组件中，调用 `setUser(currentUser)` 时报错，提示 `User | null` 类型不能赋值给 `SetStateAction<null>`。
*   **产生原因**: 使用 `useState(null)` 初始化状态时，TypeScript 会将状态类型严格推断为 `null`，导致状态更新函数 `setUser` 只接受 `null`。
*   **解决方法**: 在 `useState` 初始化时提供明确的泛型类型，指明状态可能包含的类型：`useState<User | null>(null)`。确保 `User` 类型已从 `@supabase/supabase-js` 导入。

## 6. TypeScript: 函数调用参数数量错误 (`Expected 0 arguments, but got 1`)

*   **问题简述**: 在 `src/app/auth/confirm/route.ts` 中调用 `createClient(cookieStore)` 时报错。
*   **产生原因**: 导入的 `createClient` 函数（来自 `@/utils/supabase/server`）在其定义中并不接受任何参数（它在内部调用 `cookies()`），而调用时却传递了 `cookieStore` 参数。
*   **解决方法**: 移除调用 `createClient()` 时传递的参数，使其与函数定义匹配。同时移除了因此变得未使用的 `cookieStore` 变量和 `cookies` 导入。

## 7. TypeScript: 未使用的 `@ts-expect-error` 指令

*   **问题简述**: 在修复了 `createClient` 调用错误后，之前为 `supabase.auth.verifyOtp` 添加的 `@ts-expect-error` 注释变成了未使用状态，导致新的构建错误。
*   **产生原因**: 底层的类型错误（`verifyOtp` 的参数问题）因为 `createClient` 的正确初始化而消失了，使得 `@ts-expect-error` 不再需要。
*   **解决方法**: 直接移除该行 `@ts-expect-error` 注释。

## 8. ESLint: 其他规则错误 (例如 `@next/next/no-html-link-for-pages`)

*   **问题简述**: 早期在 `error/page.tsx` 中使用了 `<a>` 标签进行内部导航。
*   **产生原因**: 违反了 Next.js 的规则，内部导航应使用 `<Link>` 组件以利用客户端路由。
*   **解决方法**: 将 `<a>` 标签替换为从 `next/link` 导入的 `<Link>` 组件。
